<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flow in Single Element Stack Â· ClimateMachine</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="ClimateMachine logo"/></a><div class="docs-package-name"><span class="docs-autofit">ClimateMachine</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../GettingStarted/Installation/">Installation</a></li><li><a class="tocitem" href="../../../GettingStarted/RunningClimateMachine/">Running</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Defaults</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../GettingStarted/Atmos/">Atmosphere model configurations</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dry_rayleigh_benard/">Dry Rayleigh Bernard</a></li><li><a class="tocitem" href="../heldsuarez/">Dry Idealized GCM</a></li><li><a class="tocitem" href="../risingbubble/">Rising Thermal Bubble</a></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Microphysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Microphysics/ex_1_saturation_adjustment/">Saturation adjustment</a></li><li><a class="tocitem" href="../../Microphysics/ex_2_Kessler/">Kessler</a></li><li class="is-active"><a class="tocitem" href>Flow in Single Element Stack</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Preliminary-configuration-1"><span>Preliminary configuration</span></a></li><li><a class="tocitem" href="#Loading-code-1"><span>Loading code</span></a></li><li><a class="tocitem" href="#Initialization-1"><span>Initialization</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1"><span>Define the set of Partial Differential Equations (PDEs)</span></a></li><li><a class="tocitem" href="#Define-the-model-1"><span>Define the model</span></a></li><li><a class="tocitem" href="#Define-the-variables-1"><span>Define the variables</span></a></li><li><a class="tocitem" href="#Define-the-compute-kernels-1"><span>Define the compute kernels</span></a></li><li class="toplevel"><a class="tocitem" href="#Spatial-discretization-1"><span>Spatial discretization</span></a></li><li class="toplevel"><a class="tocitem" href="#Time-discretization-1"><span>Time discretization</span></a></li><li class="toplevel"><a class="tocitem" href="#Configure-a-ClimateMachine-solver.-1"><span>Configure a <code>ClimateMachine</code> solver.</span></a></li><li><a class="tocitem" href="#Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1"><span>Inspect the initial conditions for a single node (e.g. the southwest node)</span></a></li><li><a class="tocitem" href="#Inspect-the-initial-conditions-for-the-horizontal-average-1"><span>Inspect the initial conditions for the horizontal average</span></a></li><li class="toplevel"><a class="tocitem" href="#Solver-hooks-/-callbacks-1"><span>Solver hooks / callbacks</span></a></li><li class="toplevel"><a class="tocitem" href="#Solve-1"><span>Solve</span></a></li><li class="toplevel"><a class="tocitem" href="#Post-processing-1"><span>Post-processing</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Ocean</span></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-3-1"><span class="docs-label">Heat</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Land/Heat/heat_equation/">Heat Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-4-1" type="checkbox"/><label class="tocitem" for="menuitem-3-4-1"><span class="docs-label">System Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Numerics/SystemSolvers/cg/">Conjugate Gradient</a></li><li><a class="tocitem" href="../../Numerics/SystemSolvers/bgmres/">Batched Generalized Minimal Residual</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">DG Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topo/">Topology</a></li><li><a class="tocitem" href="../../Numerics/DGMethods/nonnegative/">Preserving positivity</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-5-1" type="checkbox"/><label class="tocitem" for="menuitem-3-5-1"><span class="docs-label">Debug</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Diagnostics/Debug/StateCheck/">State Statistics Regression</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../literate_markdown/">Notes on Literate</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to-guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Common/Thermodynamics/">Thermodynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Atmos/TemperatureProfiles/">TemperatureProfiles</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><span class="tocitem">Meshes</span></li><li><input class="collapse-toggle" id="menuitem-4-5-2" type="checkbox"/><label class="tocitem" for="menuitem-4-5-2"><span class="docs-label">DG methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/">How to make a balance law</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-3" type="checkbox"/><label class="tocitem" for="menuitem-4-5-3"><span class="docs-label">ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Numerics/ODESolvers/Timestepping/">Time-integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-4" type="checkbox"/><label class="tocitem" for="menuitem-4-5-4"><span class="docs-label">System Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Numerics/SystemSolvers/IterativeSolvers/">Iterative Solvers</a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/">Home</a></li><li><a class="tocitem" href="../../../APIs/Driver/">Driver</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../APIs/Atmos/Microphysics/">Microphysics</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Common/SurfaceFluxes/">Surface Fluxes</a></li><li><a class="tocitem" href="../../../APIs/Common/Thermodynamics/">Thermodynamics</a></li></ul></li><li><a class="tocitem" href="../../../APIs/Arrays/Arrays/">Arrays</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Diagnostics/Diagnostics/">List of variables</a></li><li><a class="tocitem" href="../../../APIs/Diagnostics/InputOutput/">Input/Output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-9" type="checkbox"/><label class="tocitem" for="menuitem-5-9"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Numerics/Meshes/Mesh/">Meshes</a></li><li><a class="tocitem" href="../../../APIs/Numerics/SystemSolvers/SystemSolvers/">SystemSolvers</a></li><li><a class="tocitem" href="../../../APIs/Numerics/ODESolvers/ODESolvers/">ODESolvers</a></li><li><a class="tocitem" href="../../../APIs/Numerics/DGMethods/BalanceLawOverview/">Balance Law</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../Contributing/">Contribution guide</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Theory/Common/SurfaceFluxes/">SurfaceFluxes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Theory/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../Theory/Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../Theory/Atmos/EDMFEquations/">EDMF equations</a></li><li><a class="tocitem" href="../../../Theory/Atmos/Model/turbulence/">Turbulence</a></li><li><a class="tocitem" href="../../../Theory/Atmos/Model/tracers/">Tracers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DevDocs/CodeStyle/">Coding style</a></li><li><a class="tocitem" href="../../../DevDocs/AcceptableUnicode/">Acceptable Unicode</a></li><li><a class="tocitem" href="../../../DevDocs/VariableList/">Variable list</a></li><li><a class="tocitem" href="../../../DevDocs/DiagnosticVariables/">Diagnostic variable list</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Atmos</a></li><li><a class="is-disabled">Microphysics</a></li><li class="is-active"><a href>Flow in Single Element Stack</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Flow in Single Element Stack</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/burgers_single_stack.jl" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations-1"><a class="docs-heading-anchor" href="#Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations-1">Single stack tutorial based on the 3D Burgers + tracer equations</a><a class="docs-heading-anchor-permalink" href="#Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations-1" title="Permalink"></a></h1><p>Equations solved:</p><p>`` Balance law form: \frac{â Ï}{â t} = - â â (Ïu) \frac{â Ïu}{â t} = - â â (-Î¼ âu) - â â (Ïu u&#39;) - Î³[ (Ïu-ÏÌuÌ) - (Ïu-ÏÌuÌ)âzÌ zÌ] \frac{â ÏcT}{â t} = - â â (-Î± âÏcT) - â â (u ÏcT)</p><p>Boundary conditions: z<em>min: Ï = 1 z</em>min: Ïu = 0 z<em>min: ÏcT = T=T</em>fixed</p><p>z<em>max: Ï = 1 z</em>max: Ïu = 0 z_max: ÏcT = no flux</p><p>``</p><p>where</p><ul><li><code>t</code> is time</li><li><code>Ï</code> is the density</li><li><code>u</code> is the velocity vector</li><li><code>Î¼</code> is the dynamic viscosity tensor</li><li><code>Î³</code> is the Rayleigh friction frequency</li><li><code>T</code> is the temperature</li><li><code>Î±</code> is the thermal diffusivity</li><li><code>c</code> is the heat capacity</li><li><code>ÏcT</code> is the thermal energy</li></ul><p>Solving these equations is broken down into the following steps:</p><ol><li>Preliminary configuration</li><li>PDEs</li><li>Space discretization</li><li>Time discretization</li><li>Solver hooks / callbacks</li><li>Solve</li><li>Post-processing</li></ol><h1 id="Preliminary-configuration-1"><a class="docs-heading-anchor" href="#Preliminary-configuration-1">Preliminary configuration</a><a class="docs-heading-anchor-permalink" href="#Preliminary-configuration-1" title="Permalink"></a></h1><h2 id="Loading-code-1"><a class="docs-heading-anchor" href="#Loading-code-1">Loading code</a><a class="docs-heading-anchor-permalink" href="#Loading-code-1" title="Permalink"></a></h2><p>First, we&#39;ll load our pre-requisites</p><ul><li>load external packages:</li></ul><pre><code class="language-julia">using MPI
using Distributions
using NCDatasets
using OrderedCollections
using Plots
using StaticArrays
using LinearAlgebra: Diagonal</code></pre><ul><li>load CLIMAParameters and set up to use it:</li></ul><pre><code class="language-julia">using CLIMAParameters
struct EarthParameterSet &lt;: AbstractEarthParameterSet end
const param_set = EarthParameterSet()</code></pre><pre><code class="language-none">Main.ex-burgers_single_stack.EarthParameterSet()</code></pre><ul><li>load necessary ClimateMachine modules:</li></ul><pre><code class="language-julia">using ClimateMachine
using ClimateMachine.Mesh.Topologies
using ClimateMachine.Mesh.Grids
using ClimateMachine.Writers
using ClimateMachine.DGMethods
using ClimateMachine.DGMethods.NumericalFluxes
using ClimateMachine.DGMethods: BalanceLaw, LocalGeometry
using ClimateMachine.MPIStateArrays
using ClimateMachine.GenericCallbacks
using ClimateMachine.ODESolvers
using ClimateMachine.VariableTemplates
using ClimateMachine.SingleStackUtils</code></pre><ul><li>import necessary ClimateMachine modules: (<code>import</code>ing enables us to</li></ul><p>provide implementations of these structs/methods)</p><pre><code class="language-julia">import ClimateMachine.DGMethods:
    vars_state_auxiliary,
    vars_state_conservative,
    vars_state_gradient,
    vars_state_gradient_flux,
    source!,
    flux_second_order!,
    flux_first_order!,
    compute_gradient_argument!,
    compute_gradient_flux!,
    update_auxiliary_state!,
    nodal_update_auxiliary_state!,
    init_state_auxiliary!,
    init_state_conservative!,
    boundary_state!</code></pre><h2 id="Initialization-1"><a class="docs-heading-anchor" href="#Initialization-1">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-1" title="Permalink"></a></h2><p>Define the float type (<code>Float64</code> or <code>Float32</code>)</p><pre><code class="language-julia">FT = Float64;</code></pre><p>Initialize ClimateMachine for CPU.</p><pre><code class="language-julia">ClimateMachine.init(; disable_gpu = true);

const clima_dir = dirname(dirname(pathof(ClimateMachine)));</code></pre><p>Load some helper functions for plotting</p><pre><code class="language-julia">include(joinpath(clima_dir, &quot;docs&quot;, &quot;plothelpers.jl&quot;));</code></pre><h1 id="Define-the-set-of-Partial-Differential-Equations-(PDEs)-1"><a class="docs-heading-anchor" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1">Define the set of Partial Differential Equations (PDEs)</a><a class="docs-heading-anchor-permalink" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1" title="Permalink"></a></h1><h2 id="Define-the-model-1"><a class="docs-heading-anchor" href="#Define-the-model-1">Define the model</a><a class="docs-heading-anchor-permalink" href="#Define-the-model-1" title="Permalink"></a></h2><p>Model parameters can be stored in the particular <a href="../../../APIs/Numerics/DGMethods/BalanceLawOverview/#ClimateMachine.DGMethods.BalanceLaw"><code>BalanceLaw</code></a>, in this case, the <code>BurgersEquation</code>:</p><pre><code class="language-julia">Base.@kwdef struct BurgersEquation{FT} &lt;: BalanceLaw
    &quot;Parameters&quot;
    param_set::AbstractParameterSet = param_set
    &quot;Heat capacity&quot;
    c::FT = 1
    &quot;Vertical dynamic viscosity&quot;
    Î¼v::FT = 1e-4
    &quot;Horizontal dynamic viscosity&quot;
    Î¼h::FT = 1e-2
    &quot;Thermal diffusivity&quot;
    Î±::FT = 0.01
    &quot;IC Gaussian noise standard deviation&quot;
    Ï::FT = 1e-1
    &quot;Rayleigh damping&quot;
    Î³::FT = Î¼h / 0.08 / 1e-2 / 1e-2
    &quot;Domain height&quot;
    zmax::FT = 1
    &quot;Initial conditions for temperature&quot;
    initialT::FT = 295.15
    &quot;Bottom boundary value for temperature (Dirichlet boundary conditions)&quot;
    T_bottom::FT = 300.0
    &quot;Top flux (Î±âÏcT) at top boundary (Neumann boundary conditions)&quot;
    flux_top::FT = 0.0
end</code></pre><p>Create an instance of the <code>BurgersEquation</code>:</p><pre><code class="language-julia">m = BurgersEquation{FT}();</code></pre><p>This model dictates the flow control, using <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">Dynamic Multiple Dispatch</a>, for which kernels are executed.</p><h2 id="Define-the-variables-1"><a class="docs-heading-anchor" href="#Define-the-variables-1">Define the variables</a><a class="docs-heading-anchor-permalink" href="#Define-the-variables-1" title="Permalink"></a></h2><p>All of the methods defined in this section were <code>import</code>ed in # <a href="generated/Atmos/@ref">Loading code</a> to let us provide implementations for our <code>BurgersEquation</code> as they will be used by the solver.</p><p>Specify auxiliary variables for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state_auxiliary(::BurgersEquation, FT) = @vars(z::FT, T::FT);</code></pre><p>Specify state variables, the variables solved for in the PDEs, for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state_conservative(::BurgersEquation, FT) =
    @vars(Ï::FT, Ïu::SVector{3, FT}, ÏcT::FT);</code></pre><p>Specify state variables whose gradients are needed for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state_gradient(::BurgersEquation, FT) = @vars(u::SVector{3, FT}, ÏcT::FT);</code></pre><p>Specify gradient variables for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state_gradient_flux(::BurgersEquation, FT) =
    @vars(Î¼âu::SMatrix{3, 3, FT, 9}, Î±âÏcT::SVector{3, FT});</code></pre><h2 id="Define-the-compute-kernels-1"><a class="docs-heading-anchor" href="#Define-the-compute-kernels-1">Define the compute kernels</a><a class="docs-heading-anchor-permalink" href="#Define-the-compute-kernels-1" title="Permalink"></a></h2><p>Specify the initial values in <code>aux::Vars</code>, which are available in <code>init_state_conservative!</code>. Note that</p><ul><li>this method is only called at <code>t=0</code></li><li><code>aux.z</code> and <code>aux.T</code> are available here because we&#39;ve specified <code>z</code> and <code>T</code></li></ul><p>in <code>vars_state_auxiliary</code></p><pre><code class="language-julia">function init_state_auxiliary!(
    m::BurgersEquation,
    aux::Vars,
    geom::LocalGeometry,
)
    aux.z = geom.coord[3]
    aux.T = m.initialT
end;</code></pre><p>Specify the initial values in <code>state::Vars</code>. Note that</p><ul><li>this method is only called at <code>t=0</code></li><li><code>state.Ï</code>, <code>state.Ïu</code> and<code>state.ÏcT</code> are available here because</li></ul><p>we&#39;ve specified <code>Ï</code>, <code>Ïu</code> and <code>ÏcT</code> in <code>vars_state_conservative</code></p><pre><code class="language-julia">function init_state_conservative!(
    m::BurgersEquation,
    state::Vars,
    aux::Vars,
    coords,
    t::Real,
)
    z = aux.z
    Îµ1 = rand(Normal(0, m.Ï))
    Îµ2 = rand(Normal(0, m.Ï))
    state.Ï = 1
    Ïu = 1 - 4 * (z - m.zmax / 2)^2 + Îµ1
    Ïv = 1 - 4 * (z - m.zmax / 2)^2 + Îµ2
    Ïw = 0
    state.Ïu = SVector(Ïu, Ïv, Ïw)

    state.ÏcT = state.Ï * m.c * aux.T
end;</code></pre><p>The remaining methods, defined in this section, are called at every time-step in the solver by the <a href="../../../APIs/Numerics/DGMethods/BalanceLawOverview/#ClimateMachine.DGMethods.BalanceLaw"><code>BalanceLaw</code></a> framework.</p><p>Overload <code>update_auxiliary_state!</code> to call <code>heat_eq_nodal_update_aux!</code>, or any other auxiliary methods</p><pre><code class="language-julia">function update_auxiliary_state!(
    dg::DGModel,
    m::BurgersEquation,
    Q::MPIStateArray,
    t::Real,
    elems::UnitRange,
)
    nodal_update_auxiliary_state!(heat_eq_nodal_update_aux!, dg, m, Q, t, elems)
    return true # TODO: remove return true
end;</code></pre><p>Compute/update all auxiliary variables at each node. Note that</p><ul><li><code>aux.T</code> is available here because we&#39;ve specified <code>T</code> in</li></ul><p><code>vars_state_auxiliary</code></p><pre><code class="language-julia">function heat_eq_nodal_update_aux!(
    m::BurgersEquation,
    state::Vars,
    aux::Vars,
    t::Real,
)
    aux.T = state.ÏcT / (state.Ï * m.c)
end;</code></pre><p>Since we have second-order fluxes, we must tell <code>ClimateMachine</code> to compute the gradient of <code>ÏcT</code> and <code>u</code>. Here, we specify how <code>ÏcT</code>, <code>u</code> are computed. Note that <code>transform.ÏcT</code> and <code>transform.u</code> are available here because we&#39;ve specified <code>ÏcT</code> and <code>u</code>in <code>vars_state_gradient</code></p><pre><code class="language-julia">function compute_gradient_argument!(
    m::BurgersEquation,
    transform::Vars,
    state::Vars,
    aux::Vars,
    t::Real,
)
    transform.ÏcT = state.ÏcT
    transform.u = state.Ïu / state.Ï
end;</code></pre><p>Specify where in <code>diffusive::Vars</code> to store the computed gradient from <code>compute_gradient_argument!</code>. Note that:</p><ul><li><code>diffusive.Î¼âu</code> is available here because we&#39;ve specified <code>Î¼âu</code> in</li></ul><p><code>vars_state_gradient_flux</code></p><ul><li><code>âtransform.u</code> is available here because we&#39;ve specified <code>u</code> in</li></ul><p><code>vars_state_gradient</code></p><ul><li><code>diffusive.Î¼âu</code> is built using an anisotropic diffusivity tensor</li></ul><pre><code class="language-julia">function compute_gradient_flux!(
    m::BurgersEquation,
    diffusive::Vars,
    âtransform::Grad,
    state::Vars,
    aux::Vars,
    t::Real,
)
    diffusive.Î±âÏcT = m.Î± * âtransform.ÏcT
    diffusive.Î¼âu = Diagonal(SVector(m.Î¼h, m.Î¼h, m.Î¼v)) * âtransform.u
end;</code></pre><p>Introduce Rayleigh friction towards a target profile as a source. Note that:</p><ul><li>Rayleigh damping is only applied in the horizontal by subtracting</li></ul><p>the vertical component of momentum from the momentum vector.</p><pre><code class="language-julia">function source!(
    m::BurgersEquation{FT},
    source::Vars,
    state::Vars,
    diffusive::Vars,
    aux::Vars,
    args...,
) where {FT}
    áº = SVector{3, FT}(0, 0, 1)
    ÏÌuÌ =
        state.Ï * SVector{3, FT}(
            0.5 - 2 * (aux.z - m.zmax / 2)^2,
            0.5 - 2 * (aux.z - m.zmax / 2)^2,
            0.0,
        )
    Ïu_p = state.Ïu - ÏÌuÌ
    source.Ïu -= m.Î³ * (Ïu_p - zÌ&#39; * Ïu_p * zÌ)
end;</code></pre><p>Compute advective flux. Note that:</p><ul><li><code>state.Ïu</code> is available here because we&#39;ve specified <code>Ïu</code> in</li></ul><p><code>vars_state_conservative</code></p><pre><code class="language-julia">function flux_first_order!(
    m::BurgersEquation,
    flux::Grad,
    state::Vars,
    aux::Vars,
    t::Real,
)
    flux.Ï = state.Ïu

    u = state.Ïu / state.Ï
    flux.Ïu = state.Ïu * u&#39;
    flux.ÏcT = u * state.ÏcT
end;</code></pre><p>Compute diffusive flux (e.g. <span>$F(Î¼, u, t) = -Î¼âu$</span> in the original PDE). Note that:</p><ul><li><code>diffusive.Î¼âu</code> is available here because we&#39;ve specified <code>Î¼âu</code> in</li></ul><p><code>vars_state_gradient_flux</code></p><pre><code class="language-julia">function flux_second_order!(
    m::BurgersEquation,
    flux::Grad,
    state::Vars,
    diffusive::Vars,
    hyperdiffusive::Vars,
    aux::Vars,
    t::Real,
)
    flux.ÏcT -= diffusive.Î±âÏcT
    flux.Ïu -= diffusive.Î¼âu
end;</code></pre><h3 id="Boundary-conditions-1"><a class="docs-heading-anchor" href="#Boundary-conditions-1">Boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions-1" title="Permalink"></a></h3><p>Second-order terms in our equations, <span>$ââ(G)$</span> where <span>$G = Î¼âu$</span>, are internally reformulated to first-order unknowns. Boundary conditions must be specified for all unknowns, both first-order and second-order unknowns which have been reformulated.</p><p>The boundary conditions for <code>Ï</code>, <code>Ïu</code> and <code>ÏcT</code> (first order unknown)</p><pre><code class="language-julia">function boundary_state!(
    nf,
    m::BurgersEquation,
    stateâº::Vars,
    auxâº::Vars,
    nâ»,
    stateâ»::Vars,
    auxâ»::Vars,
    bctype,
    t,
    _...,
)
    if bctype == 1 # bottom
        stateâº.Ï = 1
        stateâº.Ïu = SVector(0, 0, 0)
        stateâº.ÏcT = stateâº.Ï * m.c * m.T_bottom
    elseif bctype == 2 # top
        stateâº.Ï = 1
        stateâº.Ïu = SVector(0, 0, 0)
    end
end;</code></pre><p>The boundary conditions for <code>Ï</code>, <code>Ïu</code> and <code>ÏcT</code> are specified here for second-order unknowns</p><pre><code class="language-julia">function boundary_state!(
    nf,
    m::BurgersEquation,
    stateâº::Vars,
    diffâº::Vars,
    auxâº::Vars,
    nâ»,
    stateâ»::Vars,
    diffâ»::Vars,
    auxâ»::Vars,
    bctype,
    t,
    _...,
)
    if bctype == 1 # bottom
        stateâº.Ï = 1
        stateâº.Ïu = SVector(0, 0, 0)
        stateâº.ÏcT = stateâº.Ï * m.c * m.T_bottom
    elseif bctype == 2 # top
        stateâº.Ï = 1
        stateâº.Ïu = SVector(0, 0, 0)
        diffâº.Î±âÏcT = -nâ» * m.flux_top
    end
end;</code></pre><h1 id="Spatial-discretization-1"><a class="docs-heading-anchor" href="#Spatial-discretization-1">Spatial discretization</a><a class="docs-heading-anchor-permalink" href="#Spatial-discretization-1" title="Permalink"></a></h1><p>Prescribe polynomial order of basis functions in finite elements</p><pre><code class="language-julia">N_poly = 5;</code></pre><p>Specify the number of vertical elements</p><pre><code class="language-julia">nelem_vert = 20;</code></pre><p>Specify the domain height</p><pre><code class="language-julia">zmax = m.zmax;</code></pre><p>Establish a <code>ClimateMachine</code> single stack configuration</p><pre><code class="language-julia">driver_config = ClimateMachine.SingleStackConfiguration(
    &quot;BurgersEquation&quot;,
    N_poly,
    nelem_vert,
    zmax,
    param_set,
    m,
    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),
);</code></pre><pre><code class="language-none">â Info: Model composition
â     param_set = Main.ex-burgers_single_stack.EarthParameterSet()
â     c = 1.0
â     Î¼v = 0.0001
â     Î¼h = 0.01
â     Î± = 0.01
â     Ï = 0.1
â     Î³ = 1250.0
â     zmax = 1.0
â     initialT = 295.15
â     T_bottom = 300.0
â     flux_top = 0.0
â Info: Establishing single stack configuration for BurgersEquation
â     precision        = Float64
â     polynomial order = 5
â     domain_min       = 0.00 m x0.00 m x0.00 m
â     domain_max       = 1.00 m x1.00 m x1.00 m
â     #vert elems      = 20
â     MPI ranks        = 1
â     min(Î_horz)      = 0.12 m
â     min(Î_vert)      = 0.01 m</code></pre><h1 id="Time-discretization-1"><a class="docs-heading-anchor" href="#Time-discretization-1">Time discretization</a><a class="docs-heading-anchor-permalink" href="#Time-discretization-1" title="Permalink"></a></h1><p>Specify simulation time (SI units)</p><pre><code class="language-julia">t0 = FT(0)
timeend = FT(10)</code></pre><pre><code class="language-none">10.0</code></pre><p>We&#39;ll define the time-step based on the [Fourier number] and the [Courant number] of the flow</p><pre><code class="language-julia">Î = min_node_distance(driver_config.grid)

given_Fourier = FT(0.08);
Fourier_bound = given_Fourier * Î^2 / max(m.Î±, m.Î¼h);
Courant_bound = FT(0.1) * Î
dt = min(Fourier_bound, Courant_bound)</code></pre><pre><code class="language-none">0.0002759950040694205</code></pre><h1 id="Configure-a-ClimateMachine-solver.-1"><a class="docs-heading-anchor" href="#Configure-a-ClimateMachine-solver.-1">Configure a <code>ClimateMachine</code> solver.</a><a class="docs-heading-anchor-permalink" href="#Configure-a-ClimateMachine-solver.-1" title="Permalink"></a></h1><p>This initializes the state vector and allocates memory for the solution in space (<code>dg</code> has the model <code>m</code>, which describes the PDEs as well as the function used for initialization). This additionally initializes the ODE solver, by default an explicit Low-Storage <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta</a> method.</p><pre><code class="language-julia">solver_config =
    ClimateMachine.SolverConfiguration(t0, timeend, driver_config, ode_dt = dt);</code></pre><pre><code class="language-none">[ Info: Initializing BurgersEquation</code></pre><h2 id="Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1"><a class="docs-heading-anchor" href="#Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1">Inspect the initial conditions for a single node (e.g. the southwest node)</a><a class="docs-heading-anchor-permalink" href="#Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1" title="Permalink"></a></h2><p>Let&#39;s export a plot of the initial state</p><pre><code class="language-julia">output_dir = @__DIR__;

mkpath(output_dir);

z_scale = 100 # convert from meters to cm
z_key = &quot;z&quot;
z_label = &quot;z [cm]&quot;
z = get_z(driver_config.grid, z_scale)
state_vars = get_vars_from_nodal_stack(
    driver_config.grid,
    solver_config.Q,
    vars_state_conservative(m, FT),
    i = 1,
    j = 1,
);
aux_vars = get_vars_from_nodal_stack(
    driver_config.grid,
    solver_config.dg.state_auxiliary,
    vars_state_auxiliary(m, FT),
    i = 1,
    j = 1,
    exclude = [z_key],
);
all_vars = OrderedDict(state_vars..., aux_vars...);</code></pre><p>Generate plots of initial conditions</p><pre><code class="language-julia">export_plot_snapshot(
    z,
    all_vars,
    (&quot;ÏcT&quot;,),
    joinpath(output_dir, &quot;initial_condition_T.png&quot;),
    z_label,
);
export_plot_snapshot(
    z,
    all_vars,
    (&quot;Ïu[1]&quot;,),
    joinpath(output_dir, &quot;initial_condition_u.png&quot;),
    z_label,
);
export_plot_snapshot(
    z,
    all_vars,
    (&quot;Ïu[2]&quot;,),
    joinpath(output_dir, &quot;initial_condition_v.png&quot;),
    z_label,
);</code></pre><h2 id="Inspect-the-initial-conditions-for-the-horizontal-average-1"><a class="docs-heading-anchor" href="#Inspect-the-initial-conditions-for-the-horizontal-average-1">Inspect the initial conditions for the horizontal average</a><a class="docs-heading-anchor-permalink" href="#Inspect-the-initial-conditions-for-the-horizontal-average-1" title="Permalink"></a></h2><p>Horizontal statistics of variables</p><pre><code class="language-julia">state_vars_var = get_horizontal_variance(
    driver_config.grid,
    solver_config.Q,
    vars_state_conservative(m, FT),
);

state_vars_avg = get_horizontal_mean(
    driver_config.grid,
    solver_config.Q,
    vars_state_conservative(m, FT),
);

export_plot_snapshot(
    z,
    state_vars_avg,
    (&quot;Ïu[1]&quot;,),
    joinpath(output_dir, &quot;initial_condition_avg_u.png&quot;),
    z_label,
);
export_plot_snapshot(
    z,
    state_vars_var,
    (&quot;Ïu[1]&quot;,),
    joinpath(output_dir, &quot;initial_condition_variance_u.png&quot;),
    z_label,
);</code></pre><p><img src="../initial_condition_avg_u.png" alt/> <img src="../initial_condition_variance_u.png" alt/></p><h1 id="Solver-hooks-/-callbacks-1"><a class="docs-heading-anchor" href="#Solver-hooks-/-callbacks-1">Solver hooks / callbacks</a><a class="docs-heading-anchor-permalink" href="#Solver-hooks-/-callbacks-1" title="Permalink"></a></h1><p>Define the number of outputs from <code>t0</code> to <code>timeend</code></p><pre><code class="language-julia">const n_outputs = 5;</code></pre><p>This equates to exports every ceil(Int, timeend/n_outputs) time-step:</p><pre><code class="language-julia">const every_x_simulation_time = ceil(Int, timeend / n_outputs);</code></pre><p>Create a dictionary for <code>z</code> coordinate (and convert to cm) NCDatasets IO:</p><pre><code class="language-julia">dims = OrderedDict(z_key =&gt; collect(z));

data_var = Dict([k =&gt; Dict() for k in 0:n_outputs]...)
data_var[0] = deepcopy(state_vars_var)

data_avg = Dict([k =&gt; Dict() for k in 0:n_outputs]...)
data_avg[0] = deepcopy(state_vars_avg)</code></pre><pre><code class="language-none">OrderedCollections.OrderedDict{Any,Any} with 5 entries:
  &quot;Ï&quot;     =&gt; [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  â¦  1.0, 1.0, 1.â¦
  &quot;Ïu[1]&quot; =&gt; [-0.00599263, 0.0298293, 0.0827164, 0.138657, 0.184064, 0.19257, 0â¦
  &quot;Ïu[2]&quot; =&gt; [-0.0171371, 0.0650692, 0.0837849, 0.1325, 0.172105, 0.215149, 0.2â¦
  &quot;Ïu[3]&quot; =&gt; [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  â¦  0.0, 0.0, 0.â¦
  &quot;ÏcT&quot;   =&gt; [295.15, 295.15, 295.15, 295.15, 295.15, 295.15, 295.15, 295.15, 2â¦</code></pre><p>The <code>ClimateMachine</code>&#39;s time-steppers provide hooks, or callbacks, which allow users to inject code to be executed at specified intervals. In this callback, the state and aux variables are collected, combined into a single <code>OrderedDict</code> and written to a NetCDF file (for each output step <code>step</code>).</p><pre><code class="language-julia">step = [0];
callback = GenericCallbacks.EveryXSimulationTime(
    every_x_simulation_time,
    solver_config.solver,
) do (init = false)
    state_vars_var = get_horizontal_variance(
        driver_config.grid,
        solver_config.Q,
        vars_state_conservative(m, FT),
    )
    state_vars_avg = get_horizontal_mean(
        driver_config.grid,
        solver_config.Q,
        vars_state_conservative(m, FT),
    )
    step[1] += 1
    data_var[step[1]] = deepcopy(state_vars_var)
    data_avg[step[1]] = deepcopy(state_vars_avg)
    nothing
end;</code></pre><h1 id="Solve-1"><a class="docs-heading-anchor" href="#Solve-1">Solve</a><a class="docs-heading-anchor-permalink" href="#Solve-1" title="Permalink"></a></h1><p>This is the main <code>ClimateMachine</code> solver invocation. While users do not have access to the time-stepping loop, code may be injected via <code>user_callbacks</code>, which is a <code>Tuple</code> of <a href="generated/Atmos/@ref"><code>GenericCallbacks</code></a>.</p><pre><code class="language-julia">ClimateMachine.invoke!(solver_config; user_callbacks = (callback,))</code></pre><pre><code class="language-none">1.0058697213933248</code></pre><h1 id="Post-processing-1"><a class="docs-heading-anchor" href="#Post-processing-1">Post-processing</a><a class="docs-heading-anchor-permalink" href="#Post-processing-1" title="Permalink"></a></h1><p>Our solution has now been calculated and exported to NetCDF files in <code>output_dir</code>.</p><p>Let&#39;s plot the horizontal statistics of the solution:</p><pre><code class="language-julia">export_plot(
    z,
    data_avg,
    (&quot;Ïu[1]&quot;),
    joinpath(output_dir, &quot;solution_vs_time_u.png&quot;),
    z_label,
    xlabel = &quot;Horizontal mean rho*u&quot;,
);
export_plot(
    z,
    data_var,
    (&quot;Ïu[1]&quot;),
    joinpath(output_dir, &quot;variance_vs_time_u.png&quot;),
    z_label,
    xlabel = &quot;Horizontal variance rho*u&quot;,
);
export_plot(
    z,
    data_avg,
    (&quot;ÏcT&quot;),
    joinpath(output_dir, &quot;solution_vs_time_T.png&quot;),
    z_label,
    xlabel = &quot;Horizontal mean rho*c*T&quot;,
);
export_plot(
    z,
    data_var,
    (&quot;Ïu[3]&quot;),
    joinpath(output_dir, &quot;variance_vs_time_w.png&quot;),
    z_label,
    xlabel = &quot;Horizontal variance rho*w&quot;,
);</code></pre><p><img src="../solution_vs_time_u.png" alt/> <img src="../variance_vs_time_u.png" alt/></p><p>The results look as we would expect: they Rayleigh friction damps the horizontal velocity to the objective profile and the horizontal diffusivity damps the horizontal variance. To run this file, and inspect the solution, include this tutorial in the Julia REPL with:</p><pre><code class="language-julia">include(joinpath(&quot;tutorials&quot;, &quot;Atmos&quot;, &quot;burgers_single_stack.jl&quot;))</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Microphysics/ex_2_Kessler/">Â« Kessler</a><a class="docs-footer-nextpage" href="../../Land/Heat/heat_equation/">Heat Equation Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 June 2020 19:16">Thursday 11 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
